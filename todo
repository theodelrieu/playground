class BasicCodec<Encoder, Decoder>

func encode<T>(Iterable);
func encode<T>(Iterator, Sentinel);
func decode<T>(Iterable);
func decode<T>(Iterator, Sentinel);

-> class Encoder -> Iterable;
-> class Decoder -> Iterable;


Un Decoder qui veut tout copier pour aller plus vite retourne un iterator different que celui de son input source
Il utilise un adapteur Iterable qui prend un Iterable 

Pas la peine de contraindre Encoder <=> Decoder.

Gerer conversion de UDT ?

=======================================================================================

remove some detail folders?
later on, add support for optional padding? (enum class optional/required/none)

inline namespace

test empty strings
test variants

think about namespaces:

what about lazy vs. eager?
osef? call decode if you want eager

look at static_vector in boost containers
having an InputTransformerBlock that returns array<char, 4> (base64)

use log2 instead of hard coded values gcd(log2(sizeof(alphabet)), 8 bits)

#include <mgs/base64.hpp>

#include <mgs/base64/base64.hpp>
#include <mgs/base64/base64url.hpp>

#include <mgs/base64/base64_eager.hpp>
#include <mgs/base64/base64_lazy.hpp>

#include <mgs/lazy/base64/base64.hpp>
#include <mgs/eager/base64/base64url.hpp>

#include <mgs/base64/lazy/base64.hpp>
#include <mgs/base64/eager/base64.hpp>
#include <mgs/base64/lazy/base64url.hpp>
#include <mgs/base64/eager/base64url.hpp>

mgs::base64::base64?
mgs::base64::base64url?
mgs::base64::base64url_unpadded?

mgs::codecs::base64?
mgs::codecs::base64url?
mgs::codecs::base64url_unpadded?

users will have to write usings anyway
