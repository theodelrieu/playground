class BasicCodec<Encoder, Decoder>

func encode<T>(Iterable);
func encode<T>(Iterator, Sentinel);
func decode<T>(Iterable);
func decode<T>(Iterator, Sentinel);

-> class Encoder -> Iterable;
-> class Decoder -> Iterable;


Un Decoder qui veut tout copier pour aller plus vite retourne un iterator different que celui de son input source
Il utilise un adapteur Iterable qui prend un Iterable 

Dans un premier temps, ecrire tous les iterateurs a la main.
Ensuite CRTP.

Pas la peine de contraindre Encoder <=> Decoder.

Responsabilite du programmeur de s'assurer que les 2 implementent le meme algo.

Le use-case pour en remplacer un par un autre ? Speed ? Differents iterateurs ?


codec variant:
Detail d'implem, exe: BaseEncoder<stuff::base64>, BaseEncoder<stuff::base64_url>

=======================================================================================

- changer namespace en cdcs
- trouver un moyen de modulariser la lib:
  + lib a part pour les concepts
  + lib de base avec les checks, definitions de codec etc
  + 1 lib par famille de codec?

- clean le code lol

virer les concepts encoder qui check seek_forward etc
pour restreindre l'utilisation aux iterators

private inheritance, then using seek_forward etc, impl<Underlying, Sentinel, Tag = iterator_category<Underlying>>;
dummy seek_backward if needed, static assert in body.
input_iterator do not need begin, only current, so forward shall not inherit from it (or add a begin attribute)

meson?
