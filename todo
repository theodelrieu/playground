class BasicCodec<Encoder, Decoder>

func encode<T>(Iterable);
func encode<T>(Iterator, Sentinel);
func decode<T>(Iterable);
func decode<T>(Iterator, Sentinel);

-> class Encoder -> Iterable;
-> class Decoder -> Iterable;


Un Decoder qui veut tout copier pour aller plus vite retourne un iterator different que celui de son input source
Il utilise un adapteur Iterable qui prend un Iterable 

Pas la peine de contraindre Encoder <=> Decoder.

Gerer conversion de UDT ?

codec variant:
Detail d'implem, exe: BaseEncoder<stuff::base64>, BaseEncoder<stuff::base64_url>

=======================================================================================

- trouver un moyen de modulariser la lib:
  + lib a part pour les concepts
  + lib de base avec les checks, definitions de codec etc
  + 1 lib par famille de codec?

meson?

- renommer stream en lazy
- base64 decoder

Ensuite,

- variantes base64 -> factoriser alphabet
- base32
- variantes base32 -> factoriser algorithm?

- Policies? Algorithm + Seek forward policies? Pour les lazy encoder?
Plus facile de decider une fois que 3 algo sont en place (dont un non texte?)
