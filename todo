test base_n, with octal too
find a way to put catch_main somewhere

base_n/detail/concepts/encoding_traits.hpp

#include <mgs/base64.hpp> // umbrella

#include <mgs/base64/base64.hpp>
#include <mgs/base64url/base64url.hpp>

// codecs

mgs::codecs::base64
mgs::codecs::base64url
mgs::codecs::base64url_unpadded

using mgs::codecs::base64;

same UDT conversion system for everyone?
I think so

// concept codec
// add default encode/decode template parameter in concept?
// What if there is no good default?

// concept ByteCodec
// TODO write down use-cases for UDT conversion
// Container or not Container, concepts for compatible UDT?

I think we have to design the UDT conversion mechanism first, with its concepts and then go to codecs.

Goals of UDT mechanism:

* Handle Containers.
* Allow users to define a way to create an instance their type with a pair of iterators.
* Only one definition for every codec.

A simple struct specialization should do the trick.

---------------

template <typename T, InputAdapter IA>
concept CodecOutput = requires (IA adapter) {
  // users have to make it SFINAE-correct themselves.
  Same<T, decltype(mgs::codecs::codec_output<T>::create(begin(adapter), end(adapter)))>;
};

template <typename T, typename Out, Iterable I>
concept Codec = requires (result_of_begin_t<I> a, result_of_end_t<I> b, I const& c) {
  // lazy, so only iterators to avoid lifetime issues.
  InputAdapter<decltype(T::make_encoder(a, b))>;
  InputAdapter<decltype(T::make_decoder(a, b))>;

  CodecOutput<Out, decltype(T::make_encoder(a, b))>;
  CodecOutput<Out, decltype(T::make_decoder(a, b))>;

  // eager, user specifies return type.
  Same<Out, decltype(T::encode<Out>(a, b))>;
  Same<Out, decltype(T::encode<Out>(c))>;
  Same<Out, decltype(T::decode<Out>(a, b))>;
  Same<Out, decltype(T::decode<Out>(c))>;

  // eager, default return type, no specific requirement on it.
  T::encode(a, b);
  T::encode(c);
  T::decode(a, b);
  T::decode(c);
};

fix concept comments:

template <typename T>
concept A = B<T> && requires()... use Same where needed

maybe pass encoder/decoder as template template arguments to basic_codec??

does not make sense to have iterators specified in a codec!!

// template template arguments

using mgs::codecs::base64;

auto encoder = base64::make_encoder(begin, end);
