
adapt test code for base64/32/16

test base_n

base_n/detail/concepts/encoding_traits.hpp

#include <mgs/base64.hpp> // umbrella

#include <mgs/base64/base64.hpp>
#include <mgs/base64url/base64url.hpp>

// codecs

mgs::codecs::base64
mgs::codecs::base64url
mgs::codecs::base64url_unpadded

using mgs::codecs::base64;

same UDT conversion system for everyone?
I think so

// concept codec
// add default encode/decode template parameter in concept?
// What if there is no good default?

// concept ByteCodec
// TODO write down use-cases for UDT conversion
// Container or not Container, concepts for compatible UDT?

I think we have to design the UDT conversion mechanism first, with its concepts and then go to codecs.

Goals of UDT mechanism:

* Handle std::* containers
* Allow users to define a way to create an instance their type with a pair of iterators.
* Only one definition for every codec.

A simple struct specialization should do the trick.

---------------

template <typename T>
concept CodecOutput = ?;

template <typename T, CodecOutput Out, Iterable I, Iterator It = result_of_begin_t<Iterable>, Sentinel<Iterator> S = result_of_end_t<Iterable>>
concept Codec = requires (It a, S b, I c){
  // eager, user specifies return type.
  { T::encode<Out>(a, b); } -> Out;
  { T::encode<Out>(c); } -> Out;
  { T::decode<Out>(a, b); } -> Out;
  { T::decode<Out>(c); } -> Out;

  // eager, default return type.
  { T::encode(a, b); } -> CodecOutput;
  { T::encode(c); } -> CodecOutput;
  { T::decode(a, b); } -> CodecOutput;
  { T::decode(c); } -> CodecOutput;

  // lazy, so only iterators to avoid lifetime issues.
  { T::make_encoder(a, b); } -> InputAdapter;
  { T::make_decoder(a, b); } -> InputAdapter;
};

fix concept comments:

template <typename T>
concept A = B<T> && requires()... use Same where needed

maybe pass encoder/decoder as template template arguments to basic_codec??

does not make sense to have iterators specified in a codec!!

// template template arguments

using mgs::codecs::base64;

auto encoder = base64::make_encoder(begin, end);
