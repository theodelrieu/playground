
adapt test code for base64/32/16

test base_n

base_n/detail/concepts/encoding_traits.hpp

#include <mgs/base64.hpp> // umbrella

#include <mgs/base64/base64.hpp>
#include <mgs/base64url/base64url.hpp>

// codecs

mgs::codecs::base64
mgs::codecs::base64url
mgs::codecs::base64url_unpadded

using mgs::codecs::base64;

same UDT conversion system for everyone?
I think so

// concept codec
// add default encode/decode template parameter in concept?
// What if there is no good default?

// concept ByteCodec
// TODO write down use-cases for UDT conversion
// Container or not Container, concepts for compatible UDT?

I think we have to design the UDT conversion mechanism first, with its concepts and then go to codecs.

Goals of UDT mechanism:

* Handle std::* containers
* Allow users to define a way to create an instance their type with a pair of iterators.

Questions:

* What granularity level? Global, per codec, both?

---------------

template <typename T, Iterable I, Iterator It = result_of_begin_t<Iterable>, Sentinel<Iterator> S = result_of_end_t<Iterable>>
concept Codec = requires {
  // eager.
  { T::encode<C>(a, b); } -> C;
  { T::encode<C>(c); } -> C;
  { T::decode<C>(a, b); } -> C;
  { T::decode<C>(c); } -> C;
  // lazy, so only iterators to avoid lifetime issues.
  { T::make_encoder(a, b); } -> InputAdapter;
  { T::make_decoder(a, b); } -> InputAdapter;
};

fix concept comments:

template <typename T>
concept A = B<T> && requires()... use Same where needed

maybe pass encoder/decoder as template template arguments to basic_codec??

does not make sense to have iterators specified in a codec!!

// template template arguments

using mgs::codecs::base64;

auto encoder = base64::make_encoder(begin, end);
